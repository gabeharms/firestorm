// HTTP Bridge script v.2.15
// Firestorm
// Tozh Taurog, Arrehn Oberlander, Tonya Souther

//
// Global Variables and CONSTANTS
//

    // Bridge platform
    string  bridgeAuth = "BRIDGEKEY";  // Filled in dynamically
    string  bridgeVersion = "2.15";    // This should match fslslbridge.cpp
    string  latestURL;
    integer viewerIsFirestorm;
    integer tryHandshakeOnce = TRUE;
    key owner;

    // Teleport
    float   TP_TARGET_DISTANCE = 1.0;// Distance to target when move to target should stop
    integer MAX_TIME_TO_TP = 10;     // (seconds) should be set to 10 for normal use
    float   TP_TIMER_TICK = 0.05;
    vector  mttVector;               // Target for llMoveToTarget() teleport
    integer startTPTimer;

    // Movelock
    integer useMoveLock = FALSE;
    integer relockMoveLockAfterMovement = FALSE;
    integer relockIsUserMoving = FALSE;

    // Flight assist
    integer isFlyingNow = -1;
    float flightAssistPushForce = 0.0;
    float flightAirCheckNormal = 1.0;
    float flightAirCheckSlow = 5.0;

    // OpenCollar/LockMeister AO interface
    integer aoEnabledOC = FALSE;
    integer aoEnabledLM = FALSE;
    integer aoChannelOC;
    integer aoChannelLM = -8888;
    integer aoListenerOC = -1;
    integer aoListenerLM = -1;
    key     aoCollarKey = NULL_KEY;

//
// Bridge platform helper functions
//

    makeSane()
    // Try and resist "accidental" damage from other scripts
    // Reset persistent prim attributes frequently set via scripts, try and stop other scripts
    {
        string myName = llGetScriptName();
        integer n = llGetInventoryNumber(INVENTORY_SCRIPT);
        if (n > 1)
        {
            llOwnerSay("<bridgeError error=injection>");
            llSleep(1.0);
            while(n)
            {
                string s = llGetInventoryName(INVENTORY_SCRIPT, --n);
                if (s != myName)
                    llSetScriptState(s, FALSE);
            }
        }
        llParticleSystem([]);
        llSetTextureAnim(FALSE, ALL_SIDES, 1, 1, 1.0, 1.0, 1.0);
        llAllowInventoryDrop(FALSE);
        llSetTorque(ZERO_VECTOR, 0);
        flight_hover(FALSE);
        isFlyingNow = -1;
        llStopMoveToTarget();
        if (useMoveLock)
        {
            movelock_init();
        }
        // Make bridge inconspicuous
        llSetLinkPrimitiveParamsFast(LINK_THIS, [
            PRIM_TEXT, "", ZERO_VECTOR, 0.0,
            PRIM_TEXTURE, ALL_SIDES, TEXTURE_TRANSPARENT, ZERO_VECTOR, ZERO_VECTOR, 0.0,
            PRIM_TEXGEN, ALL_SIDES, PRIM_TEXGEN_DEFAULT,
            PRIM_SIZE, <0.01, 0.01, 0.01>,
            PRIM_POSITION, <0.0, 0.0, -0.15>,
            PRIM_DESC, llGetObjectName(),
            PRIM_POINT_LIGHT, FALSE, ZERO_VECTOR, 0.0, 0.1, 0.01,
            PRIM_GLOW, ALL_SIDES, 0,
            PRIM_OMEGA, ZERO_VECTOR, 0.0, 0.0,
            PRIM_FULLBRIGHT, ALL_SIDES, FALSE,
            PRIM_FLEXIBLE, FALSE, 0, 0.0, 0.0, 0.0, 0.0, ZERO_VECTOR,
            PRIM_BUMP_SHINY, ALL_SIDES, PRIM_SHINY_NONE, PRIM_BUMP_NONE
        ]);
    }

    initBridge()
    {

        owner = llGetOwner();
        request_control_perms();

        // Disable all secondary stateful services
        setTimerEvent2(0);
        llSetTimerEvent(0);
        flight_hover(FALSE);
        llStopMoveToTarget();

        // Set the channel for the AO OC interface
        aoChannelOC = (integer)("0x" + llGetSubString(owner, 30, -1));
        if (aoChannelOC > 0)
        {
            aoChannelOC = -aoChannelOC;
        }

        // Remove previous AO listeners if present
        integrationCheckOC();
        integrationCheckLM();

        // Assume the worst and let the viewer convince us otherwise
        viewerIsFirestorm = FALSE;
        requestBridgeURL();

    }

    detachBridge()
    {
        llReleaseURL(latestURL);
        llRequestPermissions(owner, PERMISSION_ATTACH);
    }

    parseCommand(key httpReqID, string msg)
    {
        // Remove the <llsd><string> ... </string></llsd> wrapper
        list commandList = llParseString2List(llGetSubString(msg, 14, llStringLength(msg) - 18), ["|"], []);
        string cmd = llList2String(commandList, 0);

        // Large If statement for command processing. Shame on you, LSL!
        if (cmd == "URL Confirmed")
        {
            // We're in the right viewer, go on.
            viewerIsFirestorm = TRUE;
        }

        else if (cmd == "DetachBridge")
        {
            // HTTP request from the viewer to immediately detach LSL-Client Bridge
            // This could be passed during session or at login, as a response to "<bridgeURL> ... </bridgeVer>" handshake right after granting URL by a region
            // Note: If Bridge doesn't receive "URL Confirmed" message as a reply to handshake it'll automatically detach after next region change anyway
            detachBridge();
        }

        else if (cmd == "UseLSLFlightAssist")
        {
            float speed = llList2Float(commandList, 1);
            if (speed != flightAssistPushForce)
            {
                flightAssistPushForce = speed;
                if (flightAssistPushForce > 0)
                {
                    if (flightAssistPushForce > 5.0)
                    {
                        // No lightspeed please!
                        flightAssistPushForce = 5.0;
                    }
                    request_control_perms();
                    llSetTimerEvent(flightAirCheckNormal);
                }
                else
                {
                    llSetTimerEvent(0);
                    flight_hover(FALSE);
                }
            }
        }

        else if (cmd == "llMoveToTarget")
        {

            if (llList2String(commandList, 2) == "1")
            {
                // llMoveToTarget teleports are disabled for Second Life grids
                return;
            }

            // Pause movelock for now, if present
            if (useMoveLock)
            {
                llStopMoveToTarget();
            }

            // Get parameters
            string params = "<" + llList2String(commandList, 1) + ">";
            mttVector = (vector)params;
            vector relpos = mttVector - llGetPos();
            float groundLevel = llGround(relpos);
            if (mttVector.z < groundLevel) // Trying to go underground? I think not!
            {
                mttVector.z = groundLevel + 1;
            }
            startTPTimer = llGetUnixTime();

            // TP commands immediately configure a TP timer consumer
            setTimerEvent2(TP_TIMER_TICK);

        }

        else if (cmd == "getZOffsets")
        // Radar-specific command to get high-rez altitude data.
        // Input is list of UUIDs to query
        // Output is list of UUID:Altitude pairs
        {

            // Get parameters
            list    tUUIDs = llCSV2List(llList2String(commandList, 1));
            commandList = []; // Free memory
            integer tLength = llGetListLength(tUUIDs);
            key     tUUID; // Key for llGetobjectDetails()
            vector  tPos;
            integer i = 0;
            list    responses;

            for (i = 0; i < tLength; ++i)
            {
                tUUID = (key)llList2String(tUUIDs, i);
                tPos = llList2Vector(llGetObjectDetails(tUUID, ([OBJECT_POS])), 0);
                if (tPos.z > 1023) // We only care about results at higher altitudes.
                    responses = responses + tUUID + tPos.z; // Optimized for Mono-LSL
            }
            tUUIDs = []; // Free memory
            string body = "<llsd><string>" +llList2CSV(responses) + "</string></llsd>";
            responses = []; // Free memory
            llHTTPResponse(httpReqID, 200, body);
 
        }

        else if (cmd == "getScriptInfo")
        {
            list details = llGetObjectDetails(llList2Key(commandList, 1), ([OBJECT_NAME, OBJECT_RUNNING_SCRIPT_COUNT, OBJECT_TOTAL_SCRIPT_COUNT, OBJECT_SCRIPT_MEMORY, OBJECT_SCRIPT_TIME]));
            if (llGetListLength(details) == 5)
            {
                llOwnerSay("<bridgeGetScriptInfo>" + llList2CSV([llStringToBase64(llStringTrim(llList2String(details, 0), STRING_TRIM)), llList2String(details, 1), llList2String(details, 2), llList2Integer(details, 3) / 1024, llList2Float(details, 4) * 1000.0]) + "</bridgeGetScriptInfo>");
            }
            else
            {
                llOwnerSay("<bridgeError error=scriptinfonotfound>");
            }
        }

        else if (cmd == "UseMoveLock")
        {
            useMoveLock = llList2Integer(commandList, 1);
            if (useMoveLock)
            {
                movelock_init();
            }
            else
            {
                llStopMoveToTarget();
            }
            llOwnerSay("<bridgeMovelock state=" + (string)useMoveLock + ">");
        }

        else if (cmd == "RelockMoveLockAfterMovement")
        {
            relockMoveLockAfterMovement = llList2Integer(commandList, 1);
            if (relockMoveLockAfterMovement)
            {
                request_control_perms();
            }
        }

        else if (cmd == "ExternalIntegration")
        {
            integer integrationOpenCollar = llList2Integer(commandList, 1);
            integer integrationLockMeister = llList2Integer(commandList, 2);
            if (integrationOpenCollar != aoEnabledOC)
            {
                aoEnabledOC = integrationOpenCollar;
                integrationCheckOC();
            }
            if (integrationLockMeister != aoEnabledLM)
            {
                aoEnabledLM = integrationLockMeister;
                integrationCheckLM();
            }
        }

    }

    requestBridgeURL()
    {
        llReleaseURL(latestURL);
        latestURL = "";
        llRequestURL();
    }

//
// OpenCollar/LockMeister AO interface functions
//

    aoListenOC(key collarid, integer enabled)
    {
        llListenRemove(aoListenerOC);
        if (enabled)
        {
            aoListenerOC = llListen(aoChannelOC, "", collarid, "");
            aoCollarKey = collarid;
        }
        else
        {
            aoCollarKey = NULL_KEY;
        }
    }

    aoState(string newstate)
    {
        llOwnerSay("<clientAO state="+newstate+">");
    }

    integrationCheckOC()
    {
        if (aoEnabledOC)
        {
            aoListenOC(NULL_KEY, TRUE);
            llWhisper(aoChannelOC, "OpenCollar?");
        }
        else
        {
            aoListenOC(NULL_KEY, FALSE);
        }
    }

    integrationCheckLM()
    {
        if (aoEnabledLM)
        {
            aoListenerLM = llListen(aoChannelLM, "", NULL_KEY, "");
        }
        else
        {
            llListenRemove(aoListenerLM);
        }
    }

//
// Teleport Helper functions
//

    setTimerEvent2(float time)
    {
        if (time <= 0)
        {
            llSensorRemove();
        }
        else
        {
            llSensorRepeat("set-Timer-Event-2", NULL_KEY, AGENT_BY_LEGACY_NAME, 0.001, 0.001, time);
        }
    }

    tpMoveStep()
    {
        vector loc = llGetPos();
        vector targ = mttVector - loc;
        float dist = llVecMag(targ);

        // llOwnerSay("current: " + (string)loc + " target: " + (string)targ + " tp distance: " + (string)dist);

        // If we are out of time or distance - stop
        if ((dist < TP_TARGET_DISTANCE) || (llGetUnixTime() - MAX_TIME_TO_TP > startTPTimer) || (mttVector == loc))
        {
            llStopMoveToTarget();
            setTimerEvent2(0);
            if (useMoveLock)
            {
                movelock_init();
            }
        }
        else
        {
            if (dist < 65)
            {
                // llOwnerSay("One jump to :" + (string)mttVector);
                llMoveToTarget(mttVector, TP_TIMER_TICK);
            }
            else
            {
                // llOwnerSay("Multiple jump to :" + (string)(loc+llVecNorm(targ)*60));
                llMoveToTarget(loc+llVecNorm(targ)*60, TP_TIMER_TICK);
            }
        }

    }

//
// Movement control permission, shared function
//

    request_control_perms()
    {
        if (llGetAttached() != 0)
        {
            llRequestPermissions(owner, PERMISSION_TAKE_CONTROLS);
        }
    }

//
// Flight Assist
//

    flight_hover(integer yes)
    {
        if (yes)
        {
            llSetForce((<0.0, 0.0, 9.8> * llGetMass()), 0);
        }
        else
        {
            llSetForce(ZERO_VECTOR, 0);
        }
    }

//
// Movelock
//

    movelock_init()
    {
        llMoveToTarget(llGetPos() - <0, 0, 0.1>, 0.05);
    }

//
// MAIN
//

default
{
    state_entry()
    {
        makeSane();
        initBridge();
    }

    on_rez(integer i)
    {
        // We don't want to be rezzed without being attached. Insure we don't create litter.
        llSetLinkPrimitiveParamsFast(LINK_THIS, [PRIM_TEMP_ON_REZ, TRUE]);
        // Force Movelock, Flight Assist and external integration variables to false here and allow attach() to decide via initBridge(), if we're on Firestorm and they need to be updated / enabled.
        // on_rez() will be triggered prior to attach() when attaching from inventory or during login, but not prior to state_entry().
        useMoveLock = FALSE;
        flightAssistPushForce = 0.0;
        isFlyingNow = -1;
        aoEnabledOC = FALSE;
        aoEnabledLM = FALSE;
    }

    attach(key k)
    // Initialize bridge functionality when worn as an attachment
    {
        if (k != NULL_KEY)
        {
            tryHandshakeOnce = TRUE;
            initBridge();
        }
    }

    run_time_permissions(integer i)
    {
        if (i & PERMISSION_TAKE_CONTROLS)
        {
            if (flightAssistPushForce > 0 || relockMoveLockAfterMovement)
            {
                llTakeControls(CONTROL_FWD | CONTROL_BACK | CONTROL_LEFT | CONTROL_RIGHT | CONTROL_UP | CONTROL_DOWN, TRUE, TRUE);
            }
            else
            {
                // Take control for value that does nothing, in order to work in no-script sims
                llTakeControls(1024, TRUE, TRUE);
            }
        }
        else if (i & PERMISSION_ATTACH)
        {
            llDetachFromAvatar();
        }
    }

    control(key id, integer level, integer edge)
    {

        if (useMoveLock && relockMoveLockAfterMovement)
        {
            if (level & (CONTROL_FWD | CONTROL_BACK | CONTROL_LEFT | CONTROL_RIGHT | CONTROL_UP | CONTROL_DOWN))
            {
                if (!relockIsUserMoving)
                {
                    relockIsUserMoving = TRUE;
                    llStopMoveToTarget();
                }
            }
            else if (relockIsUserMoving)
            {
                relockIsUserMoving = FALSE;
                movelock_init();
            }
        }

        if (flightAssistPushForce > 0 && isFlyingNow)
        {
            if (level & (CONTROL_FWD | CONTROL_BACK | CONTROL_LEFT | CONTROL_RIGHT | CONTROL_UP | CONTROL_DOWN))
            {
                vector pushingForce = ZERO_VECTOR;
                // Forward / back
                if (level & CONTROL_FWD)
                {
                    pushingForce += <flightAssistPushForce, 0, 0>;
                }
                else if (level & CONTROL_BACK)
                {
                    pushingForce += <-flightAssistPushForce, 0, 0>;
                }
                // Left / right
                if (level & CONTROL_LEFT)
                {
                    pushingForce += <0, flightAssistPushForce, 0>;
                }
                else if (level & CONTROL_RIGHT)
                {
                    pushingForce += <0, -flightAssistPushForce, 0>;
                }
                // Up / down
                if (level & CONTROL_UP)
                {
                    pushingForce += <0, 0, flightAssistPushForce>;
                }
                else if (level & CONTROL_DOWN)
                {
                    pushingForce += <0, 0, -flightAssistPushForce>;
                }
                llApplyImpulse(pushingForce, 1);
            }
        }

    }

    changed(integer change)
    {
        if (change & CHANGED_REGION)
        {
            requestBridgeURL();
        }
        if (change & CHANGED_INVENTORY)
        {
            makeSane();
        }
    }

    timer()
    {
        if (llGetAgentInfo(owner) & AGENT_FLYING)
        {
            if (isFlyingNow != TRUE)
            {
                isFlyingNow = TRUE;
                flight_hover(TRUE);
                llSetTimerEvent(flightAirCheckNormal);
            }
        }
        else if (isFlyingNow != FALSE)
        {
            isFlyingNow = FALSE;
            flight_hover(FALSE);
            llSetTimerEvent(flightAirCheckSlow);
        }
    }

    no_sensor()
    {
        // Used for TP timer only
        // no_sensor() is used as a second timer() along with setTimerEvent2(), because lightweight llSensorRepeat() query is using impossible to meet requirements
        tpMoveStep();
    }

    http_request(key ID, string Method, string Body)
    {
        // llOwnerSay("Received HTTP " + Method + " message. Command body: " + Body);
        if (Method == URL_REQUEST_GRANTED)
        {
            latestURL = Body;
            // Saying URL to owner
            if (viewerIsFirestorm || tryHandshakeOnce)
            {
                // Firestorm viewer and handshake
                llOwnerSay("<bridgeURL>" + latestURL + "</bridgeURL><bridgeAuth>" + bridgeAuth + "</bridgeAuth><bridgeVer>" + bridgeVersion + "</bridgeVer>");
                tryHandshakeOnce = FALSE;
            }
            else
            {
                // We're in a wrong viewer, just sit quietly and call llDetachFromAvatar();
                // This place is reached via CHANGED_REGION - when viewerIsFirestorm is still not Firestorm and handshake was already done (tryHandshakeOnce is FALSE)
                detachBridge();
            }
        }
        else if (Method == URL_REQUEST_DENIED)
        {
            // No URLs free! Keep trying?
            llSleep(5);
            requestBridgeURL();
        }
        else if (Method == "GET" || Method == "POST")
        {
            parseCommand(ID, Body);
        }
    }

    listen(integer fromChan, string senderName, key senderID, string msg)
    {
        // llOwnerSay("listen() from "+senderName+" msg: "+msg);

        if (fromChan == aoChannelOC)     // OpenCollar AO interface
        {
            integer zhaoPos;
            if ((aoCollarKey == NULL_KEY) &&    // No collar paired yet
                (msg == "OpenCollar=Yes"))      // A collar is saying hello
            {
                aoListenOC(senderID, TRUE);     // Pair with it
            }
            else if (msg == "OpenCollar=No")    // Collar signing off
            {
                aoListenOC(NULL_KEY, TRUE);     // Unpair with it
            }
            else if ((zhaoPos = llSubStringIndex(msg, "ZHAO_")) >= 0)
            {
                zhaoPos += 5;               // Skip past prefix
                if ((llGetSubString(msg, zhaoPos, zhaoPos+4) == "AOOFF") ||
                    (llGetSubString(msg, zhaoPos, zhaoPos+7) == "STANDOFF"))
                {
                    aoState("off");
                }
                else if ((llGetSubString(msg, zhaoPos, zhaoPos+3) == "AOON") ||
                    (llGetSubString(msg, zhaoPos, zhaoPos+6) == "STANDON"))
                {
                    aoState("on");
                }
            }
        } // End OpenCollar AO interface listen handler

        else if (fromChan == aoChannelLM)        // LockMeister AO interface
        {
            key lmtarget = (key)llGetSubString(msg, 0, 35);
            list templist = llParseStringKeepNulls(llGetSubString(msg, 36, -1), [ "|" ], []);
            string command = llList2String(templist, 0);
            if (lmtarget == owner)
            {
                if (command == "booton")
                {
                    aoState("on");
                }
                else if (command == "bootoff")
                {
                    aoState("off");
                }
            }
        } // End LockMeister AO interface listen handler
    } // End listen

}
